
/*###################################
#### 19. 클로저 (closure) ########
####################################*/


// 클로저는  함수가 선언됐을 때의 렉시컬 환경을 의미한다.

function outerFunc(){
    var x =10
    var innerFunc = function(){
        console.log(x); };
        innerFunc();
    }


outerFunc();

// *스코프는 함수를 호출할 때가 아니라 함수를 어디에 선언하였는지에 따라 결정된다. 이를 렉시컬 스코핑(Lexical scoping)라 한다.
// innerFunc 은 (전역,함수outFunc,자신의 스코프)를 참조

//실행컨텍스트의 관점
// 자신의 실행컨텍스트 먼저 쌓이고-> 변수객체(V.O)와 스코프체인, this에 바인딩될 객체가 결정
// 스코프체인(전역객체, 함수outerFunc의 활성객체(Activation object), 자기함수의 활성객체 순으로 바인딩)
//즉 1.innerFunc 함수 스코프(함수 자신의 스코프를 가리키는 활성 객체) 내에서 변수 x를 검색한다. 검색이 실패하였다.
//   2. innerFunc 함수를 포함하는 외부 함수 outerFunc의 스코프(함수 outerFunc의 스코프를 가리키는 함수 outerFunc의 활성 객체)에서 변수 x를 검색한다. 검색이 성공하였다.



function outerFunc(){
    var x =10;
    var innerFunc =function(){console.log(x);};
    return innerFunc;
}

//함수 outerFunc을 호출하면 내부함수 innerFunc이 반환된다
// 그리고 "함수 outerFunc의 실행컨텍스트는 소멸한다".

var inner = outerFunc();
inner(); //10


// **함수 outerFunc는 내부함수 innerFunc를 반환하고 생을 마감했다. 즉, 함수 outerFunc는 실행된 이후 콜스택(실행 컨텍스트 스택)에서 제거되었으므로 함수 outerFunc의 변수 x 또한 더이상 유효하지 않게 되어 변수 x에 접근할 수 있는 방법은 달리 없어 보인다. 그러나 위 코드의 실행 결과는 변수 x의 값인 10이다. 이미 life-cycle이 종료되어 실행 컨텍스트 스택에서 제거된 함수 outerFunc의 지역변수 x가 다시 부활이라도 한 듯이 동작하고 있다. 뭔가 특별한 일이 일어나고 있는 것 같다.
// 이처럼 자신을 포함하고 있는 외부함수보다 내부함수가 더 오래 유지되는 경우, 외부 함수 밖에서 내부함수가 호출되더라도 외부함수의 지역 변수에 접근할 수 있는데 이러한 함수를 클로저(Closure)라고 부른다.

//요약: 클로저는 반환된 내부함수가 자신이 선언됐을 때의 환경(Lexical environment)인 스코프를 기억하여 자신이 선언됐을 때의 환경(스코프) 밖에서 호출되어도 그 환경(스코프)에 접근할 수 있는 함수
     // 클로저는 자신이 생성될 때의 환경(Lexical environment)을 기억하는 함수다
     // 사라졌지만 기억되는 외부함수의 변수 x를 '자유변수(Free variable)' 이라고 부름



/*###################################
#### 19. 2  클로저의 활용  ########
####################################*/

//2.1 상태유지

